#+TITLE: List and Patterns

* List Basics

#+BEGIN_SRC ocaml
open Base;;

[1;2;3]
#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

#+BEGIN_SRC ocaml
1 :: 2 :: [] 
#+END_SRC

#+RESULTS:
| 1 | 2 |

:: operator is right-associative, means the we can build up lists without
parenthese

#+BEGIN_SRC ocaml
let empty = [];;
3 :: empty

#+END_SRC

#+RESULTS:
| 3 |

#+BEGIN_SRC ocaml
"three" :: empty;;

#+END_SRC

#+RESULTS:
| three |


#+BEGIN_SRC ocaml
let l = 1 :: 2 :: 3 :: []

#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

#+BEGIN_SRC ocaml

let m = 0 :: l

#+END_SRC

#+RESULTS:
| 0 | 1 | 2 | 3 |

* Using Patterns to Extract Data from a List

#+BEGIN_SRC ocaml
let rec sum l = 
  match l with
  | [] -> 0
  | hd :: tl -> hd + sum tl

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
sum [1;2;3;2;3;4;5;9]

#+END_SRC

#+RESULTS:
: 29

#+BEGIN_SRC ocaml
sum []

#+END_SRC

#+RESULTS:
: 0

#+BEGIN_SRC ocaml
let rec drop_value l to_drop = 
  match l with
  | [] -> []
  | to_drop :: tl -> drop_value tl to_drop
  | hd :: tl -> hd :: drop_value tl to_drop

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
drop_value [1;2;3] 2

#+END_SRC

#+RESULTS:
: []


#+BEGIN_SRC ocaml
let rec drop_value l to_drop = 
  match l with
  | [] -> []
  | hd :: tl ->
     let new_tl = drop_value tl to_drop in 
     if hd = to_drop then new_tl else hd :: new_tl
#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec drop_zero l =
  match l with
  | [] -> []
  | 0  :: tl -> drop_zero tl
  | hd :: tl -> hd :: drop_zero tl
;;


#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
drop_zero [1;2;0;3];;

#+END_SRC

#+RESULTS:
| 1 | 2 | 3 |

* Limitations (and Blessings) of Pattern Matching

#+BEGIN_SRC ocaml
let plus_one_match x =
  match x with
  | 0 -> 1
  | 1 -> 2
  | 2 -> 3
  | 3 -> 4
  | 4 -> 5
  | 5 -> 6
  | _ -> x + 1

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let plus_one_if x =
  if      x = 0 then 1
  else if x = 1 then 2
  else if x = 2 then 3
  else if x = 3 then 4
  else if x = 4 then 5
  else if x = 5 then 6
  else x + 1
;;

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
#require "core_bench";;

open Core_bench;;
[ Bench.Test.create ~name:"plus_one_match" (fun () ->
      ignore (plus_one_match 10))
; Bench.Test.create ~name:"plus_one_if" (fun () ->
      ignore (plus_one_if 10)) ]
|> Bench.bench
;;

#+END_SRC

#+RESULTS:
: Characters 2-19:
:   [ Bench.Test.create ~name:"plus_one_match" (fun () ->
:     ^^^^^^^^^^^^^^^^^
: Error: Unbound module Bench
