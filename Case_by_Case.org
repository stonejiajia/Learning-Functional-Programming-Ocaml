#+TITLE: Case_by_Case

* Simple patter matching

#+BEGIN_SRC ocaml
let rec factorial a = 
  if a = 1 then 1 else a * factorial (a - 1)

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec factorial a = 
  match a with
    1 -> 1
  | _ -> a * factorial (a - 1)

#+END_SRC

#+RESULTS:
: <fun>

See if a matches the pattern 1, If it does, just return 1, 
If not, see if it matches the pattern_ , If is does, then return
is a * factorial (a - 1).

*The pattern _ is special , it matches anything*


#+BEGIN_SRC ocaml
let isvowel c = 
  c = 'a' || c = 'e' || c = 'i';;

#+END_SRC

#+RESULTS:
: <fun>

Here is how to write it using matching

#+BEGIN_SRC ocaml

let isvowel c = 
  match c with 
    'a' -> true
  | 'e' -> true
  | 'i' -> true
  | 'o' -> true
  | 'u' -> true
  | _   -> false

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let iscowel c = 
  match c with
    'a' | 'e' | 'i' | 'o'| 'u' -> true
    | _ -> false
             

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec gcd a b = 
  if b = 0 then a else gcd b (a mod b)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let rec gcd a b = 
  match b with
    0 -> a
  | _ -> gcd b (a mod b)

#+END_SRC

#+RESULTS:
: <fun>

We use pattern mathcing whenever it is easier to read and understand
than if then else expressions


#+BEGIN_SRC ocaml
let not x = 
  match x with
    x -> false
  | _ -> true;;

#+END_SRC

#+RESULTS:
: <fun>

* Sorting Things

#+BEGIN_SRC ocaml

let rec insert x l =
  match l with
    [] -> [x]
  | h::t -> 
     if x <= h
       then x :: h :: t
       else h :: insert x t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
insert 39 [1; 1; 2; 3; 5; 9];;

#+END_SRC

#+RESULTS:
| 1 | 1 | 2 | 3 | 5 | 9 | 39 |


#+BEGIN_SRC ocaml
let rec sort l = 
  match l with
    [] -> []
  | h::t -> insert h (sort t)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
sort [53; 9; 2; 6; 19]

#+END_SRC

#+RESULTS:
| 2 | 6 | 9 | 19 | 53 |


sort [53; 9; 2; 6; 19]

insert 53 (sort [9; 2; 6; 19])

insert 53 (insert 9 (sort [2; 6; 19])))

insert 53 (insert 9 (insert 2 sort [6; 19]))

insert 53 (insert 9 (insert 2 (insert 6 (sort [19]))))

insert 53 (insert 9 (insert 2 (insert 6 (insert 19 []))))

insert 53 (insert 9 (insert 2 (insert 6 [19]))

insert 53 (insert 9 (insert 2 [6; 19]))

insert 53 (insert 9  [2; 6; 19])

insert 53 [2; 6; 9; 19]

[2; 6; 9; 19; 53]


#+BEGIN_SRC ocaml
sort ['p'; 'i'; 'm'; 'c'; 's'; 'h'];;

#+END_SRC

#+RESULTS:
| c | h | i | m | p | s |

sort function takes time proportional to n^2

#+BEGIN_SRC ocaml

let rec merge x y =
  match x, y with
    [], l -> l
  | l, [] -> l
  | hx::tx, hy::ty ->
     if hx < hy
       then hx :: merge tx (hy :: ty)
       else hy :: merge (hx :: tx) ty

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec length l = 
  match l with
    [] -> 0
  | _::t -> 1 + length t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec msort l = 
  match l with 
    [] -> []
  | [x] -> [x]
  | _ -> 
     let left = take (length 1 / 2) l in 
     let right = drop  (length 1 / 2) l in 
     merge (msort left) (msort right)

#+END_SRC

#+RESULTS:
: Characters 102-103:
:        let left = take (length 1 / 2) l in 
:                                ^
: Error: This expression has type int but an expression was expected of type
:          'a list
