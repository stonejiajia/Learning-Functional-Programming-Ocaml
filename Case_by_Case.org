#+TITLE: Case_by_Case

* Simple patter matching

#+BEGIN_SRC ocaml
let rec factorial a = 
  if a = 1 then 1 else a * factorial (a - 1)

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec factorial a = 
  match a with
    1 -> 1
  | _ -> a * factorial (a - 1)

#+END_SRC

#+RESULTS:
: <fun>

See if a matches the pattern 1, If it does, just return 1, 
If not, see if it matches the pattern_ , If is does, then return
is a * factorial (a - 1).

*The pattern _ is special , it matches anything*


#+BEGIN_SRC ocaml
let isvowel c = 
  c = 'a' || c = 'e' || c = 'i';;

#+END_SRC

#+RESULTS:
: <fun>

Here is how to write it using matching

#+BEGIN_SRC ocaml

let isvowel c = 
  match c with 
    'a' -> true
  | 'e' -> true
  | 'i' -> true
  | 'o' -> true
  | 'u' -> true
  | _   -> false

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let iscowel c = 
  match c with
    'a' | 'e' | 'i' | 'o'| 'u' -> true
    | _ -> false
             

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec gcd a b = 
  if b = 0 then a else gcd b (a mod b)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let rec gcd a b = 
  match b with
    0 -> a
  | _ -> gcd b (a mod b)

#+END_SRC

#+RESULTS:
: <fun>

We use pattern mathcing whenever it is easier to read and understand
than if then else expressions


#+BEGIN_SRC ocaml
let not x = 
  match x with
    x -> false
  | _ -> true;;

#+END_SRC

#+RESULTS:
: <fun>

* Sorting Things

#+BEGIN_SRC ocaml

let rec insert x l =
  match l with
    [] -> [x]
  | h::t -> 
     if x <= h
       then x :: h :: t
       else h :: insert x t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
insert 39 [1; 1; 2; 3; 5; 9];;

#+END_SRC

#+RESULTS:
| 1 | 1 | 2 | 3 | 5 | 9 | 39 |


#+BEGIN_SRC ocaml
let rec sort l = 
  match l with
    [] -> []
  | h::t -> insert h (sort t)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
sort [53; 9; 2; 6; 19]

#+END_SRC

#+RESULTS:
| 2 | 6 | 9 | 19 | 53 |


sort [53; 9; 2; 6; 19]

insert 53 (sort [9; 2; 6; 19])

insert 53 (insert 9 (sort [2; 6; 19])))

insert 53 (insert 9 (insert 2 sort [6; 19]))

insert 53 (insert 9 (insert 2 (insert 6 (sort [19]))))

insert 53 (insert 9 (insert 2 (insert 6 (insert 19 []))))

insert 53 (insert 9 (insert 2 (insert 6 [19]))

insert 53 (insert 9 (insert 2 [6; 19]))

insert 53 (insert 9  [2; 6; 19])

insert 53 [2; 6; 9; 19]

[2; 6; 9; 19; 53]


#+BEGIN_SRC ocaml
sort ['p'; 'i'; 'm'; 'c'; 's'; 'h'];;

#+END_SRC

#+RESULTS:
| c | h | i | m | p | s |

sort function takes time proportional to n^2

#+BEGIN_SRC ocaml

let rec merge x y =
  match x, y with
    [], l -> l
  | l, [] -> l
  | hx::tx, hy::ty ->
     if hx < hy
       then hx :: merge tx (hy :: ty)
       else hy :: merge (hx :: tx) ty

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec length l = 
  match l with
    [] -> 0
  | _::t -> 1 + length t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec msort l = 
  match l with 
    [] -> []
  | [x] -> [x]
  | _ -> 
     let left = take (length 1 / 2) l in 
     let right = drop  (length 1 / 2) l in 
     merge (msort left) (msort right)

#+END_SRC

#+RESULTS:
: Characters 102-103:
:        let left = take (length 1 / 2) l in 
:                                ^
: Error: This expression has type int but an expression was expected of type
:          'a list

* COMMENT “Loading a Program from a File”


#+BEGIN_SRC ocaml
let rec length l = 
  match l with
    [] -> 0
  | h::t -> 1 + length t;;

let rec append a b = 
  match a with
    [] -> b
  | h::t -> h :: append t b;;

#+END_SRC

#+RESULTS:
: <fun>

* Functions upon Functions upon Functions


#+BEGIN_SRC ocaml
let rec double l = 
  match l with
    [] -> [] 
  | h::t -> (h * 2) :: double t;;

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_EXAMPLE
double [1; 2; 4]

2 :: double [2; 4]

2 :: 4 :: double [4]

2 :: 4 :: 8 :: double []

2 :: 4 :: 8 :: []

[2; 4; 8]
#+END_EXAMPLE


#+BEGIN_SRC ocaml

let rec evens l = 
  match l with
    [] -> []
  | h::t -> (h mod 2 = 0) :: evens t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
evens [1; 2; 4]

#+END_SRC

#+RESULTS:
| false | true | true |


#+BEGIN_SRC ocaml
let rec map f l = 
  match l with
    [] -> [] 
  | h::t -> f h :: map f t

#+END_SRC

#+RESULTS:
: <fun>

val map : ('a -> 'b) -> 'a list -> 'b list = <fun>


#+BEGIN_SRC ocaml
let halve x = x / 2

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml


map halve [10; 20; 30]
#+END_SRC

#+RESULTS:
| 5 | 10 | 15 |

#+BEGIN_EXAMPLE
map halve [10; 20; 30]

5 :: map halve [20; 30]

5 :: 10 :: map halve [30]

5 :: 10 :: 15 :: map halve []

5 :: 10 :: 15 :: []

[5; 10; 15]
#+END_EXAMPLE


#+BEGIN_SRC ocaml
let is_even x = 
  x mod 2 = 0

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let evens l = 
  map (fun x -> x mod 2 = 0) l

#+END_SRC

#+RESULTS:
: <fun>



#+BEGIN_SRC ocaml
map (fun x -> x / 2) [10; 20; 30]

#+END_SRC

#+RESULTS:
| 5 | 10 | 15 |

val merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list = <fun>

val msort : ('a -> 'a -> bool) -> 'a list -> 'a list = <fun>

type a -> a -> bool . That is ,it takes two elements of the same type , and 
return true, if the first is "greater" than the second


#+BEGIN_SRC ocaml
let rec merge cmp x y = 
  match x, y with 
    [], l -> l
  | l, [] -> l
  | hx::tx, hy::ty ->
     if cmp hx hy
        then hx :: merge cmp tx (hy :: ty)
        else hy :: merge cmp (hx :: tx) ty
                     
                     

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let rec msort cmp l = 
  match l with 
    [] -> []
  | [x] -> [x]
  | _ -> 
     let left = take (length l / 2) l in
       let right = drop (length l / 2) l in 
         merge cmp (msort cmp left) (msort cmp right)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml

let greater a b = 
  a >= b

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
msort greater [5; 4; 6; 2; 1]

#+END_SRC

#+RESULTS:
| 6 | 5 | 4 | 2 | 1 |


#+BEGIN_SRC ocaml
( <= )

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
msort ( <= ) [5; 4; 6; 2; 1]

#+END_SRC

#+RESULTS:
| 1 | 2 | 4 | 5 | 6 |

#+BEGIN_SRC ocaml
msort ( >= ) [5; 4; 6; 2; 1]

#+END_SRC

#+RESULTS:
| 6 | 5 | 4 | 2 | 1 |


* When Things Go Wrong

* Looking Things Up

| House | People |
|-------+--------|
|     1 |      4 |
|     2 |      2 |
|     3 |      2 |
|     4 |      3 |
|     5 |      1 |
|     6 |      2 |
|       |        |


To make a pair in OCaml

#+BEGIN_SRC ocaml
let p = (1, 4)

#+END_SRC

#+RESULTS:
: (1, 4)

val p : int * int = (1, 4)


#+BEGIN_SRC ocaml
let q = (1, '1')

#+END_SRC

#+RESULTS:
: (1, '1')

val q : int * char = (1, '1')


#+BEGIN_SRC ocaml
let fst p = match p with (x, _) -> x;;
let snd p = match p with (_, y) -> y;;

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
fst (1, 'a')

#+END_SRC

#+RESULTS:
: 1


#+BEGIN_SRC ocaml 
snd (7, 'a')

#+END_SRC

#+RESULTS:
: 'a'


#+BEGIN_SRC ocaml
let census = [(1, 4); (2, 2); (3, 2); (4, 3); (5, 1); (6, 2)]

#+END_SRC

#+RESULTS:
:   [(1, 4), (2, 2), (3, 2), (4, 3), (5, 1), (6, 2)]

val census : (int * int) list =

#+BEGIN_SRC ocaml
let y = (1, [2; 3; 4])

#+END_SRC

#+RESULTS:
| 1 | (2 3 4) |

lookup :a -> (axb) list -> b

#+BEGIN_SRC ocaml
let rec lookup x l = 
  match l with
    [] -> raise Not_found
  | (k, v)::t ->
     if k = x then v else lookup x t
#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec add k v d = 
  match d with
    [] -> [(k, v)]
  | (k', v')::t ->
     if k = k'
        then (k, v) :: t
        else (k', v') :: add k v t    
#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
add 8 2 [(4, 5); (6, 3)]

#+END_SRC



| 4 | 5 |
| 6 | 3 |
| 8 | 2 |


* More with Functions

#+BEGIN_SRC ocaml
let add x y = x + y

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let f = add 6

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml 

f 5

#+END_SRC

#+RESULTS:
: 11


#+BEGIN_SRC ocaml

map (add 6) [10; 20; 30]

#+END_SRC


| 16 | 26 | 36 |


#+BEGIN_SRC ocaml

map (fun x -> x * 2) [10; 20; 30]

#+END_SRC

#+RESULTS:
| 20 | 40 | 60 |


* New Kinds of Data

The name of type is colour. It has four constructors, Red, Green, and Yellow


#+BEGIN_SRC ocaml

type colour = Red | Green | Blue | Yellow

#+END_SRC

#+RESULTS:
: type colour = Red | Green | Blue | Yellow


#+BEGIN_SRC ocaml
let col = Blue

let cols = [Red; Red; Green; Yellow]
             
let colpair = ('R', Red)

#+END_SRC

#+RESULTS:
: ('R', Red)


#+BEGIN_SRC ocaml
type colour = 
  Red
| Green
| Blue
| Yellow
| RGB of int * int * int

#+END_SRC

#+RESULTS:
: type colour = Red | Green | Blue | Yellow | RGB of int * int * int

#+BEGIN_SRC ocaml
let cols = [Red; Red; Green; Yellow; RGB (150, 0, 255);]

#+END_SRC

#+RESULTS:
| Red | Red | Green | Yellow | RGB | (150 0 255) |

我们可用 Pattern matching 的 functions 来代替新的 Type

We can write functions by pattern matching over our new type

#+BEGIN_SRC ocaml
let components c = 
  match c with 
    Red -> (255, 0, 0)
  | Green -> (0, 255, 0)
  | Blue -> (0, 0, 255)
  | Yellow -> (255, 255, 0)
  | RGB (r, g, b) -> (r, g, b)

#+END_SRC

#+RESULTS:
: <fun>

Type could be polymorphic. 

#+BEGIN_SRC ocaml
type 'a option = None | Some of 'a

#+END_SRC

#+RESULTS:
: type 'a option = None | Some of 'a

We can read as "a value of type a optio is either nothing, or something of type a"

#+BEGIN_SRC ocaml
let nothing = None

let number = Some 50
               
let numbers = [Some 12; None; None; Some 2]
                
let word = Some ['c'; 'a'; 'k'; 'e']

#+END_SRC

#+RESULTS:
: Some ['c', 'a', 'k', 'e']


Here is a function to look up a value in a dictionary, return None, instead of
raising an exception if the value is not found

#+BEGIN_SRC ocaml

let rec lookup_opt x l = 
  match l with
    [] -> None
  | (k, v)::t -> if x = k then Some v else lookup_opt x t
#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
type 'a sequence = Nil | Cons of 'a * 'a sequence

#+END_SRC

#+RESULTS:
: type 'a sequence = Nil | Cons of 'a * 'a sequence


| Built-in                | Ours                                      | Our Type       |
|-------------------------+-------------------------------------------+----------------|
| []                      | Nil                                       | a sequence     |
| [1]                     | Cons (1, Nil)                             | int sequence   |
| ['a'; 'x'; 'e']         | Cons ('a', Cons ('x', Cons ('e', Nil)))   | char sequence  |
| [Red; RGB (20, 20, 20)] | COns (Red, Cons (RGB (20, 20 , 20), Nil)) | color sequence |

#+BEGIN_SRC ocaml
let rec length l = 
  match l with
    [] -> 0
  | _::t -> 1 + length t
                  
let rec append a b =
  match a with 
    [] -> b
  | h::t -> h :: append t b

#+END_SRC

#+RESULTS:
: <fun>

Web can creat same functions with new sequence type:

#+BEGIN_SRC ocaml
let rec length s = 
  match s with
    Nil -> 0
  | Cons (_, t) -> 1 + length t
                         
let rec append a b = 
  match a with
    Nil -> b
  | Cons (h, t) -> Cons (h, append t b)

#+END_SRC

#+RESULTS:
: <fun>


** A Type for Mathematical Expressions

#+BEGIN_SRC ocaml
type expr = 
  Num of int 
| Add of expr * expr
| Subtract of expr * expr
| Multiply of expr * expr
| Divide of expr * expr

#+END_SRC

#+RESULTS:
: type expr =
:     Num of int
:   | Add of expr * expr
:   | Subtract of expr * expr
:   | Multiply of expr * expr
:   | Divide of expr * expr

#+BEGIN_SRC ocaml
Add (Num 1, Multiply (Num 2, Num 3))

#+END_SRC

#+RESULTS:
: Add (Num 1, Multiply (Num 2, Num 3))

Wen can write a same function

#+BEGIN_SRC ocaml
let rec evaluate e = 
  match e with
    Num x -> x
  | Add (e, e') -> evaluate e + evaluate e'
  | Subtract (e, e') -> evaluate e - evaluate e'
  | Multiply (e, e') -> evaluate e * evaluate e'
  | Divide (e, e') -> evaluate e / evaluate e'

#+END_SRC

#+RESULTS:
: <fun>


* Growing Trees

#+BEGIN_SRC ocaml
type 'a tree = 
  Br of 'a * 'a tree * 'a tree
| Lf

#+END_SRC

#+RESULTS:
: type 'a tree = Br of 'a * 'a tree * 'a tree | Lf

Two constructors

1. Br 
2. Lf (leaf)
   
The empty tree is simply

#+BEGIN_SRC ocaml
let rec size tr = 
  match tr with
    Br (_, l, r) -> 1 + size l + size r
  | Lf -> 0

#+END_SRC

#+RESULTS:
: <fun>


A similar function can be used to add up all the integers in an int tree.

#+BEGIN_SRC ocaml
let rec total tr = 
  match tr with
    Br (x, l, r) -> x + total l + total r
  | Lf -> 0

#+END_SRC

#+RESULTS:
: <fun>


Calculate the maximum depth fo tree.

#+BEGIN_SRC ocaml
let max x y = 
  if x > y then x else y;;

let rec maxdepth tr = 
  match tr with
    Br (_, l, r) -> 1 + max (maxdepth l) (maxdepth r)
  | Lf -> 0

#+END_SRC

#+RESULTS:
: <fun>

Exract all of the elements from a tree into a list

#+BEGIN_SRC ocaml
let rec list_of_tree tr = 
  match tr with
    Br (x, l, r) -> list_of_tree l @ [x] @ list_of_tree r
  | Lf -> []

#+END_SRC

#+RESULTS:
: <fun>

** Usring trees to build better dictionaries

The most important advantage of a tree is that if is often very much easier to
reach a given element.

#+BEGIN_SRC ocaml
let rec lookup tr k = 
  match tr with
    Lf -> raise Not_found
  | Br ((k', v), l, r) -> 
     if k = k' then v
     else if k < k' then lookup l k
     else lookup r k

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let rec insert tr k v = 
  match tr with
    Lf -> Br ((k, v), Lf, Lf)
  | Br ((k', v'), l, r) ->
     if k = k' then Br ((k', v'), l, r)
     else if k < k' then Br ((k', v'), insert l k v, r)
     else Br ((k', v'), l, insert r k v)


#+END_SRC

#+RESULTS:
: <fun>

