#+TITLE: Case_by_Case

* Simple patter matching

#+BEGIN_SRC ocaml
let rec factorial a = 
  if a = 1 then 1 else a * factorial (a - 1)

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec factorial a = 
  match a with
    1 -> 1
  | _ -> a * factorial (a - 1)

#+END_SRC

#+RESULTS:
: <fun>

See if a matches the pattern 1, If it does, just return 1, 
If not, see if it matches the pattern_ , If is does, then return
is a * factorial (a - 1).

*The pattern _ is special , it matches anything*


#+BEGIN_SRC ocaml
let isvowel c = 
  c = 'a' || c = 'e' || c = 'i';;

#+END_SRC

#+RESULTS:
: <fun>

Here is how to write it using matching

#+BEGIN_SRC ocaml

let isvowel c = 
  match c with 
    'a' -> true
  | 'e' -> true
  | 'i' -> true
  | 'o' -> true
  | 'u' -> true
  | _   -> false

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let iscowel c = 
  match c with
    'a' | 'e' | 'i' | 'o'| 'u' -> true
    | _ -> false
             

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec gcd a b = 
  if b = 0 then a else gcd b (a mod b)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let rec gcd a b = 
  match b with
    0 -> a
  | _ -> gcd b (a mod b)

#+END_SRC

#+RESULTS:
: <fun>

We use pattern mathcing whenever it is easier to read and understand
than if then else expressions


#+BEGIN_SRC ocaml
let not x = 
  match x with
    x -> false
  | _ -> true;;

#+END_SRC

#+RESULTS:
: <fun>

* Sorting Things

#+BEGIN_SRC ocaml

let rec insert x l =
  match l with
    [] -> [x]
  | h::t -> 
     if x <= h
       then x :: h :: t
       else h :: insert x t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
insert 39 [1; 1; 2; 3; 5; 9];;

#+END_SRC

#+RESULTS:
| 1 | 1 | 2 | 3 | 5 | 9 | 39 |


#+BEGIN_SRC ocaml
let rec sort l = 
  match l with
    [] -> []
  | h::t -> insert h (sort t)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
sort [53; 9; 2; 6; 19]

#+END_SRC

#+RESULTS:
| 2 | 6 | 9 | 19 | 53 |


sort [53; 9; 2; 6; 19]

insert 53 (sort [9; 2; 6; 19])

insert 53 (insert 9 (sort [2; 6; 19])))

insert 53 (insert 9 (insert 2 sort [6; 19]))

insert 53 (insert 9 (insert 2 (insert 6 (sort [19]))))

insert 53 (insert 9 (insert 2 (insert 6 (insert 19 []))))

insert 53 (insert 9 (insert 2 (insert 6 [19]))

insert 53 (insert 9 (insert 2 [6; 19]))

insert 53 (insert 9  [2; 6; 19])

insert 53 [2; 6; 9; 19]

[2; 6; 9; 19; 53]


#+BEGIN_SRC ocaml
sort ['p'; 'i'; 'm'; 'c'; 's'; 'h'];;

#+END_SRC

#+RESULTS:
| c | h | i | m | p | s |

sort function takes time proportional to n^2

#+BEGIN_SRC ocaml

let rec merge x y =
  match x, y with
    [], l -> l
  | l, [] -> l
  | hx::tx, hy::ty ->
     if hx < hy
       then hx :: merge tx (hy :: ty)
       else hy :: merge (hx :: tx) ty

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec length l = 
  match l with
    [] -> 0
  | _::t -> 1 + length t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let rec msort l = 
  match l with 
    [] -> []
  | [x] -> [x]
  | _ -> 
     let left = take (length 1 / 2) l in 
     let right = drop  (length 1 / 2) l in 
     merge (msort left) (msort right)

#+END_SRC

#+RESULTS:
: Characters 102-103:
:        let left = take (length 1 / 2) l in 
:                                ^
: Error: This expression has type int but an expression was expected of type
:          'a list

* COMMENT “Loading a Program from a File”


#+BEGIN_SRC ocaml
let rec length l = 
  match l with
    [] -> 0
  | h::t -> 1 + length t;;

let rec append a b = 
  match a with
    [] -> b
  | h::t -> h :: append t b;;

#+END_SRC

#+RESULTS:
: <fun>

* Functions upon Functions upon Functions


#+BEGIN_SRC ocaml
let rec double l = 
  match l with
    [] -> [] 
  | h::t -> (h * 2) :: double t;;

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_EXAMPLE
double [1; 2; 4]

2 :: double [2; 4]

2 :: 4 :: double [4]

2 :: 4 :: 8 :: double []

2 :: 4 :: 8 :: []

[2; 4; 8]
#+END_EXAMPLE


#+BEGIN_SRC ocaml

let rec evens l = 
  match l with
    [] -> []
  | h::t -> (h mod 2 = 0) :: evens t

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
evens [1; 2; 4]

#+END_SRC

#+RESULTS:
| false | true | true |


#+BEGIN_SRC ocaml
let rec map f l = 
  match l with
    [] -> [] 
  | h::t -> f h :: map f t

#+END_SRC

#+RESULTS:
: <fun>

val map : ('a -> 'b) -> 'a list -> 'b list = <fun>


#+BEGIN_SRC ocaml
let halve x = x / 2

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml


map halve [10; 20; 30]
#+END_SRC

#+RESULTS:
| 5 | 10 | 15 |

#+BEGIN_EXAMPLE
map halve [10; 20; 30]

5 :: map halve [20; 30]

5 :: 10 :: map halve [30]

5 :: 10 :: 15 :: map halve []

5 :: 10 :: 15 :: []

[5; 10; 15]
#+END_EXAMPLE


#+BEGIN_SRC ocaml
let is_even x = 
  x mod 2 = 0

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
let evens l = 
  map (fun x -> x mod 2 = 0) l

#+END_SRC

#+RESULTS:
: <fun>



#+BEGIN_SRC ocaml
map (fun x -> x / 2) [10; 20; 30]

#+END_SRC

#+RESULTS:
| 5 | 10 | 15 |

val merge : ('a -> 'a -> bool) -> 'a list -> 'a list -> 'a list = <fun>

val msort : ('a -> 'a -> bool) -> 'a list -> 'a list = <fun>

type a -> a -> bool . That is ,it takes two elements of the same type , and 
return true, if the first is "greater" than the second


#+BEGIN_SRC ocaml
let rec merge cmp x y = 
  match x, y with 
    [], l -> l
  | l, [] -> l
  | hx::tx, hy::ty ->
     if cmp hx hy
        then hx :: merge cmp tx (hy :: ty)
        else hy :: merge cmp (hx :: tx) ty
                     
                     

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml
let rec msort cmp l = 
  match l with 
    [] -> []
  | [x] -> [x]
  | _ -> 
     let left = take (length l / 2) l in
       let right = drop (length l / 2) l in 
         merge cmp (msort cmp left) (msort cmp right)

#+END_SRC

#+RESULTS:
: <fun>


#+BEGIN_SRC ocaml

let greater a b = 
  a >= b

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
msort greater [5; 4; 6; 2; 1]

#+END_SRC

#+RESULTS:
| 6 | 5 | 4 | 2 | 1 |


#+BEGIN_SRC ocaml
( <= )

#+END_SRC

#+RESULTS:
: <fun>

#+BEGIN_SRC ocaml
msort ( <= ) [5; 4; 6; 2; 1]

#+END_SRC

#+RESULTS:
| 1 | 2 | 4 | 5 | 6 |

#+BEGIN_SRC ocaml
msort ( >= ) [5; 4; 6; 2; 1]

#+END_SRC

#+RESULTS:
| 6 | 5 | 4 | 2 | 1 |


* When Things Go Wrong

